┏━━━━━━━━━━━━━━━━┓
┃   2025-10-02   ┃
┗━━━━━━━━━━━━━━━━┛

I asked Grok all about how iTerm2 and terminals work.

I'm turning off the Erlang "interactive shell" as it just reads from the PTY input (stdin) and
competes with the C NIF.

`man 4 termios`
- Shows how c_cc VMIN and VTIME work.
  - c_cc is the character array

                                         ┌────────────┐
                                         │ Keys       │
                                         │ Interrupts │
                                         └───┬────────┘        Session
                                             │                ┌────────────────┐
                                             │                │ ┌─────────┐    │
┌────────┐        ┌─────────┐   ┌──────────┐ │  ┌─────────┐   │ │ Process │    │
│        │        │ Master  │   │          │ │  │ Slave   │   │ │ Group   │    │
│ iTerm2 ├──keys─►│ PTY     ├──►│ Kernel   ├─┴─►│ PTY     ├──►│ │         │    │
│        │        │         │   │          │    │         │   │ │         │    │
└────────┘        └─────────┘   └────┬─────┘    └─────────┘   │ └──────┬──┘    │
                                     │                        │        │       │
                                     │                        │        │       │
                                     │                        └────────│───────┘
                                ┌────────────┐                         │
                                │ Line       │                         │
                                │ Discipline │◄────────────────────────┘
                                └────────────┘ line discipline settings

┏━━━━━━━━━━━━━━━━┓
┃   2025-09-30   ┃
┗━━━━━━━━━━━━━━━━┛

How iTerm2, Erlang, and the TTY all work together

                                                    +---------------+ 
+-------------------+     +---------------+     <-  |   Keyboard    |
| Erlang TTY Driver | <-> | iTerm2|       |         +---------------+
+-------------------+     +---------------+     
          |                                     
+-------------------+                                - kernel-level contstruct
|   tty_sl_drv.c    |                               +---------------+
+-------------------+                           <-> | OS TTY Device |
                                                    +---------------+

My NIF
- Runs after Erlang TTY driver

Erlang TTY Driver - tty_sl_drv.c
- interface with PTY for stdin,stdout,stderr
- Reads and writes to PTY
- {noshell, raw} still uses tty_sl_drv.c

iTerm2
- frontend for terminal
- dispaly pty output                     
- renders text       
- process kb input       
- interacts with PTY (TTY)

OS TTY Device
- kernel level construct
- /dev/ptyXX + /dev/ttysXXX
- facilitates comms between term emu (iTerm2) and running program (Erlang)
- PTY handles low-level terminal settings via the termios structure
  - if input is echoed
  - if special characters (like Ctrl+C) generate signals
  - if input is processed in canonical (line-based) or raw mode.


[User] -> [iTerm2] -> [PTY (macOS kernel)] -> [Erlang TTY Driver] -> [Erlang VM] -> [Your Application/NIF]


++++++++++++++++++++++++++++++++++++++++++++++++++

Grok:

Let’s dive into your questions about the Erlang TTY driver, its role in the chain of components (iTerm2, Erlang VM, TTY, etc.), and the specific points about `termios` settings, the `stty` command, and integrating the fix into your NIF. I’ll address each part systematically, keeping the context of your Erlang project using `{noshell, raw}` mode on a 2024 MacBook Pro M4 running macOS Sequoia 15 with OTP 28, and your goal of recreating a Vim/Neovim-like TUI.

---

### 1. The Erlang TTY Driver and Its Role in the Chain

The **Erlang TTY driver** is a component within the Erlang Runtime System (ERTS) that handles terminal I/O for the Erlang VM. Specifically, it’s implemented in the `tty_sl_drv.c` file (located in `erts/emulator/drivers/unix/tty_sl_drv.c` in the OTP source). Its role is to manage interaction between the Erlang VM and the operating system’s terminal device (TTY) for standard input/output operations. Let’s break down the chain of components:

- **iTerm2**: This is your terminal emulator, a macOS application that provides a user interface to interact with a TTY (pseudo-terminal, or PTY). It handles rendering text, processing keyboard input, and forwarding it to the underlying PTY. iTerm2 translates your keypresses (e.g., Ctrl+C) into bytes sent to the PTY, and it displays output from the PTY. It’s essentially the front-end for terminal interaction.

- **PTY (Pseudo-Terminal)**: The PTY is a kernel-level construct provided by macOS (a Unix-like system). It’s a pair of devices (`/dev/ptyXX` or `/dev/ttysXXX` on macOS) that facilitates communication between the terminal emulator (iTerm2) and the process running in it (Erlang VM). The PTY handles low-level terminal settings via the `termios` structure, which controls things like whether input is echoed, whether special characters (like Ctrl+C) generate signals, and whether input is processed in canonical (line-based) or raw mode.

- **Erlang TTY Driver (`tty_sl_drv.c`)**: This is part of the Erlang VM’s ERTS, specifically in the `erts/emulator/drivers` directory. The driver is responsible for interfacing the Erlang VM with the PTY for standard I/O (stdin/stdout/stderr). It reads input from the PTY (key presses) and writes output to it (text to display). The driver also interprets certain control characters (like Ctrl+C, which is ASCII 3, or `^C`) unless explicitly disabled. In your case, the driver is involved because you’re running in `{noshell, raw}` mode, which attempts to bypass Erlang’s default shell processing but still uses the TTY driver for I/O.

- **Erlang VM**: The VM runs your Erlang application (`cm_shell_app`) and manages processes like `cs_io_nif` and `cs_io`. It relies on the TTY driver to handle low-level I/O with the PTY. Your application uses a C NIF (`term_driver_nif.c`) to set the terminal to raw mode and read input, but the VM’s TTY driver is already active when your NIF runs.

- **Your NIF (`term_driver_nif.c`)**: Your Native Interface Function (NIF) directly manipulates the PTY’s `termios` settings (via `tcsetattr` and `cfmakeraw`) to enable raw mode and read individual keypresses. However, it runs *after* the Erlang VM and its TTY driver have initialized, which is why Ctrl+C is still processed by the driver.

**Chain Summary**:
```
[User] -> [iTerm2] -> [PTY (macOS kernel)] -> [Erlang TTY Driver] -> [Erlang VM] -> [Your Application/NIF]
```
- **User** types in iTerm2.
- **iTerm2** sends keypresses as bytes to the PTY.
- **PTY** applies `termios` settings (e.g., raw or cooked mode, signal handling for Ctrl+C).
- **Erlang TTY Driver** reads from the PTY and may interpret special characters (like Ctrl+C) before passing input to your application.
- **Erlang VM** runs your `cs_io` and `cs_io_nif` modules, which also interact with the PTY via the NIF.
- **Your NIF** tries to set raw mode and read keys directly, but the TTY driver’s initial configuration can interfere.

The issue with Ctrl+C arises because the Erlang TTY driver, initialized at VM startup, checks for the interrupt character (Ctrl+C, ASCII 3) before your NIF has a chance to fully disable signal handling.

---

### 2. Driver Capturing `termios` Settings at VM Startup

The Erlang TTY driver initializes when the Erlang VM starts, before your application’s `cs_io_nif` module runs its `init/1` function. Here’s what happens, based on the `tty_sl_drv.c` code and your setup:

- **At VM Startup**:
  - The TTY driver opens the PTY (e.g., `/dev/ttysXXX`) associated with stdin and calls `tcgetattr` to capture the initial `termios` settings. These settings are typically in **cooked mode** (canonical mode), where:
    - `ISIG` is enabled, meaning special characters like `VINTR` (Ctrl+C) generate a SIGINT signal.
    - `VINTR` is set to `^C` (ASCII 3), the default interrupt character.
  - The driver stores these settings and sets a flag (`drv->intr = 1`) if `ISIG` is enabled and `VINTR` is defined. This enables the driver to check for Ctrl+C independently of the PTY’s later configuration.
  - The driver’s input handling loop (in `tty_sl_drv.c`) checks each input byte against `VINTR`. If it detects Ctrl+C, it triggers the Erlang break handler, which pauses the VM and waits for user input (e.g., `a` to abort, `c` to continue). Multiple rapid Ctrl+C presses (double or more) cause the VM to exit.

- **Your NIF’s Role**:
  - In your `cs_io_nif.erl` and `term_driver_nif.c`, you call `set_raw_mode()` during the `init/1` function of the `cs_io_nif` gen_server. This uses `cfmakeraw()` to disable `ISIG`, `ECHO`, `ICANON`, and other flags, and sets `VMIN=1` and `VTIME=0` for non-blocking single-byte reads.
  - However, this happens *after* the TTY driver has already initialized and captured the cooked-mode settings. The driver’s `intr` check remains active because it was set based on the initial `termios` configuration, not the one your NIF applies later.

- **Why Ctrl+C Still Gets Through**:
  - Even though your NIF disables `ISIG` in the PTY’s `termios` settings, the Erlang TTY driver doesn’t recheck the `termios` settings after initialization. It continues to monitor for `VINTR` (Ctrl+C) based on the initial state (`drv->intr = 1`).
  - In `{noshell, raw}` mode (introduced in OTP 28 via `shell:start_interactive({noshell, raw})`), the VM bypasses some shell-related processing (like line editing), but the TTY driver’s interrupt handling remains active unless `ISIG` and `VINTR` are disabled *before* the VM starts.

This mismatch—your NIF setting raw mode after the driver’s initialization—causes Ctrl+C to be intercepted by the driver instead of being passed as a raw byte (ASCII 3) to your `read_key()` function.

---

### 3. The `stty raw -echo isig=0 intr=undef` Command

The suggested `stty` command in the shell script modifies the PTY’s `termios` settings *before* launching the Erlang VM, ensuring the TTY driver sees a disabled `VINTR` from the start. Let’s break down the command:

```bash
stty raw -echo isig=0 intr=undef
```

- **`stty`**: A Unix utility that configures terminal settings by modifying the `termios` structure for the current PTY (stdin’s associated device, e.g., `/dev/ttysXXX`).

- **`raw`**: Sets the PTY to raw mode, equivalent to calling `cfmakeraw()` in your NIF. This disables:
  - Canonical mode (`ICANON`), so input is not buffered into lines.
  - Input processing flags like `ICRNL` (CR-to-NL mapping).
  - Output processing (`OPOST`).
  - Signal-generating characters (`ISIG`), though we explicitly reinforce this below.

- **`-echo`**: Disables `ECHO`, so keypresses (including Ctrl+C) are not echoed to the terminal display.

- **`isig=0`**: Explicitly disables the `ISIG` flag, which prevents special characters like `VINTR` (Ctrl+C), `VQUIT` (Ctrl+\), and `VSUSP` (Ctrl+Z) from generating signals (SIGINT, SIGQUIT, SIGTSTP).

- **`intr=undef`**: Sets the `VINTR` character (normally Ctrl+C) to undefined, effectively disabling the interrupt character. In `termios`, this sets `term.c_cc[VINTR]` to `_POSIX_VDISABLE` (typically 0 or an invalid value), ensuring no keypress triggers a SIGINT.

- **Effect**:
  - When this command runs *before* `erl`, the PTY is already in raw mode with `ISIG` off and `VINTR` undefined when the Erlang TTY driver initializes.
  - The driver calls `tcgetattr` and sees `ISIG=0` or `VINTR` undefined, so it sets `drv->intr = 0`, disabling its Ctrl+C check.
  - As a result, Ctrl+C is treated as a regular byte (ASCII 3) and passed to your `read_key()` NIF function instead of triggering the break handler.

- **Restoring the Terminal**:
  - The script ends with `; stty sane`, which restores the PTY to a sensible cooked mode after the Erlang VM exits, preventing a messed-up terminal (e.g., no echo, no line buffering).
  - Your `restore_term()` NIF function also helps by restoring the original `termios` settings, but the `stty sane` ensures cleanup even if the VM crashes.

**Example Script** (from your provided `shell` document, modified):
```bash
#!/usr/bin/env zsh
rebar3 compile && stty raw -echo isig=0 intr=undef && erl -noshell -pa _build/default/lib/cm_shell/ebin -config sys.config -s cm_shell_app start ; stty sane
```

This ensures the PTY is configured correctly before the VM starts, preventing the TTY driver from intercepting Ctrl+C.

---

### 4. Integrating the Fix into Your NIF and Safety Considerations

The `stty` approach works externally, but you can achieve similar results by modifying your NIF to ensure `VINTR` is disabled *before* the Erlang VM fully initializes. However, this is tricky because the TTY driver initializes early, and NIFs typically load later (e.g., during `cs_io_nif:init/1`). Here’s how to approach it and address the safety concerns:

#### Integrating into the NIF

To disable `VINTR` in your NIF, you need to explicitly set `term.c_cc[VINTR] = _POSIX_VDISABLE` before calling `tcsetattr`. Your current `set_raw_mode()` function already uses `cfmakeraw()`, which disables `ISIG`, but explicitly disabling `VINTR` reinforces this. Here’s a modified version of your `set_raw_mode()` in `term_driver_nif.c`:

```c
#include <erl_nif.h>
#include <termios.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>

static struct termios original_term;

void set_raw_mode() {
    struct termios term;
    tcgetattr(STDIN_FILENO, &original_term); // Save original settings
    term = original_term;
    cfmakeraw(&term); // Set raw mode (disables ICANON, ECHO, ISIG, etc.)
    term.c_cc[VINTR] = _POSIX_VDISABLE; // Explicitly disable VINTR (Ctrl+C)
    term.c_cc[VMIN] = 1; // Read at least 1 byte
    term.c_cc[VTIME] = 0; // No timeout
    if (tcsetattr(STDIN_FILENO, TCSANOW, &term) == -1) {
        fprintf(stderr, "tcsetattr failed: %s\n", strerror(errno));
    }
}
```

**Challenge**: The NIF’s `set_raw_mode()` is called in `cs_io_nif:init/1`, which runs after the TTY driver has initialized. To fully disable the driver’s `VINTR` check, you’d need to set the PTY’s `termios` settings *before* the VM starts or modify the driver itself. Since modifying the Erlang VM’s source (`tty_sl_drv.c`) is impractical for your project, the `stty` approach is more reliable.

**Alternative**: If you want to avoid relying on the shell script, you could write a small C program or script to set the PTY’s `termios` settings before launching `erl`. For example:

```c
// pre_erl_raw.c
#include <termios.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

int main() {
    struct termios term;
    tcgetattr(STDIN_FILENO, &term);
    cfmakeraw(&term);
    term.c_cc[VINTR] = _POSIX_VDISABLE;
    tcsetattr(STDIN_FILENO, TCSANOW, &term);
    system("erl -noshell -pa _build/default/lib/cm_shell/ebin -config sys.config -s cm_shell_app start");
    system("stty sane"); // Restore terminal
    return 0;
}
```

Compile and run this before launching your app:

```bash
gcc pre_erl_raw.c -o pre_erl_raw
./pre_erl_raw
```

This achieves the same effect as the `stty` command but is more controlled and portable.

#### Safety Considerations

- **Unclean Exits**: Raw mode can leave the terminal in a broken state (e.g., no echo, no line buffering) if the VM crashes or exits without calling `restore_term()`. Your `term_driver_nif.c` already includes `restore_term()`, which is great, but it’s only called in `cs_io_nif:terminate/2`. Ensure it’s called even on abnormal exits by:
  - Registering a signal handler in your NIF to catch SIGTERM/SIGINT and call `restore_term()`.
  - Using the shell script’s `stty sane` as a fallback.

  Example signal handler in C:

  ```c
  #include <signal.h>

  void signal_handler(int sig) {
      restore_term();
      exit(1);
  }

  void set_raw_mode() {
      signal(SIGINT, signal_handler);
      signal(SIGTERM, signal_handler);
      struct termios term;
      tcgetattr(STDIN_FILENO, &original_term);
      term = original_term;
      cfmakeraw(&term);
      term.c_cc[VINTR] = _POSIX_VDISABLE;
      term.c_cc[VMIN] = 1;
      term.c_cc[VTIME] = 0;
      if (tcsetattr(STDIN_FILENO, TCSANOW, &term) == -1) {
          fprintf(stderr, "tcsetattr failed: %s\n", strerror(errno));
      }
  }
  ```

- **Trapping Signals in Zsh**: To ensure the terminal is restored even if the VM crashes, modify your shell script to trap signals and run `stty sane`:

  ```bash
  #!/usr/bin/env zsh
  trap 'stty sane' EXIT INT TERM
  rebar3 compile && stty raw -echo isig=0 intr=undef && erl -noshell -pa _build/default/lib/cm_shell/ebin -config sys.config -s cm_shell_app start
  ```

  This traps `EXIT`, `INT` (Ctrl+C), and `TERM` signals, running `stty sane` to restore the terminal.

- **Testing**: Test the modified script or NIF thoroughly:
  - Press Ctrl+C to confirm it’s passed as ASCII 3 to your `read_key()` function (visible in your `io:format` output as `[3]`).
  - Simulate crashes (e.g., kill the VM process) to ensure `stty sane` or `restore_term()` restores the terminal.
  - Verify that other special keys (e.g., arrow keys, escape sequences) are correctly handled by your `cs_esc:parse_escape_code/1`.

---

### Summary

- **Erlang TTY Driver**: Part of ERTS, it interfaces the VM with the PTY, capturing `termios` settings at startup and checking for `VINTR` (Ctrl+C) unless disabled. It sits between the PTY and your application in the chain: `iTerm2 -> PTY -> TTY Driver -> VM -> Your NIF/App`.
- **Initial `termios` Capture**: The driver grabs the PTY’s cooked-mode settings (with `ISIG` enabled and `VINTR=^C`) at VM startup, enabling Ctrl+C checks before your NIF sets raw mode.
- **`stty raw -echo isig=0 intr=undef`**: Configures the PTY before the VM starts, disabling `ISIG` and `VINTR` so the TTY driver doesn’t intercept Ctrl+C.
- **NIF Integration**: Explicitly set `term.c_cc[VINTR] = _POSIX_VDISABLE` in `set_raw_mode()`, but the `stty` approach or a pre-VM C program is more reliable due to timing. Add signal handlers and shell traps to ensure terminal restoration.

**Next Steps**:
1. Test the modified shell script with `stty raw -echo isig=0 intr=undef`.
2. If you prefer a NIF-based solution, try the pre-VM C program or integrate signal handling in `term_driver_nif.c`.
3. Verify Ctrl+C appears as `[3]` in your `cs_io:input_loop/1` output and doesn’t trigger the break handler.

Let me know if you need help debugging or implementing these changes!
