┏━━━━━━━━━━━━━━━━┓
┃   2025-09-25   ┃
┗━━━━━━━━━━━━━━━━┛

Can we store implicit rows?

i.e. [x, y]

X and Y are both windows, but they are implicitly in rows because the
outermost list is a list of _rows_.

[x, y] makes a rotation easy: [x, y] -> [y, x]

However, when descending into tree, we need to know if we're in a row or a
column.

[[x, y], z]

It feels like any list flips the orientation

I'm thinking you can only rotate within a list.

So this [[x]] doesn't make any sense: it's a row, with a single column, ... I
guess it does make sense, it's just redundant ... no, [x] would be a row of one
column, as soon as we add the second list we're switching from columns to rows,
so that's a single column of 1 row. I guess it could just go on forever:
[[[x]]] row of 1 col of 1 row of 1 col

i.e.

[     ] row
 [   ]  col 1 is a row
  [ ]   col 1 is a row
   x    x

Can I get by with only rows in lists?
No, only columns in lists: a row _is_ a list of columns

+---+
| x |  [x]
+---+

+---+---+
| x | y |  [x, y]
+---+---+

+---+---+
| x |   |  [*, y] - two columns: * and y 
+---+ y |         - how do we represent two rows as a column?
| z |   |
+---+---+

          [[x],[z], y] -> [x, z, y]

          i.e. single column + single colum + single column

Let's redraw this without collapsing anything

+-------------+ 1 row, with two columns
| +---+ +---+ | First column has two rows
| | x | |   | | 
| +---+ | y | | There has to be a way for a column to have rows
| | z | |   | |
| +---+ +---+ | However, if only *only* rows can be lists, how can
+-------------+ a column _contain_ anything?

Also, how do you have a list of rows?

You *have* to have lists of rows and lists of columns. Of course, a list of rows
is a column, but you have to start somewhere. I've arbitrarily decided to start
with rows as the top level.

I guess *all* rows and all columns must be lists. Well, no, because then you
have the infinite problem in reverse: 1 row with 1 column, but that column has a
row, and that row has a column: [[[[[[[x]]]]]]]

Maybe a better rule would be: "Only columns can be *outside* of a list" ... that
doesn't make any sense. *everything* is in a list.

How about: "Only columns can be bare."

[[x]] - x doesn't need a list, because it's a column, but the row it's in has to
be a list.

Or, "Windows can be columns. Windows can never be rows."

So, [x, y] doesn't work. It has to be [[x], [y]]: two rows of one column each.

    % +---+---+  Columns have to be able to be lists, or windows.
    % |   | y |
    % | x +---+  [                         ] - list of rows
    % |   | z |    [                     ]   - one row
    % +---+---+      x, [              ]     - 2 columns: x and [...]: columns *can* be lists
    %                     [   ], [   ]       - 2 rows in the column: rows *must* be lists
    %                       y      z         - 2 windows, as columns

If I go into a row, it must be columns, which are windows or lists
If I go into a column, it *must* be lists, and only lists

┏━━━━━━━━━━━━━━━━┓
┃   2025-09-24   ┃
┗━━━━━━━━━━━━━━━━┛

Every window must be in a column. I've arbitrarily decided to
start with rows as the top level container. Windows must then be in columns
because the ... well, just because. The other option is to have both rows and
columns be implied.

Hmm, no, I think any non-list is just a window and a window can be in a row or a
column, depending on how many parnet lists it has:

1 parent:  row (because top list is arbitrarily a list of rows)
2 parents: column
3 parents: row
4 parents: column
etc.

*      - zero parents, holder of rows
  RowA     - 1 parent
    Cola   - 2 parents
      RowB - 3 parents

  Even number of parents? You're a column
  Odd number of parents? You're a row

Example data structures:

[]               - empty list of *rows*

[X, Y]           - windows X and Y are both their own rows

                 +---+
		 | X |
		 +---+
		 | Y |
		 +---+

[X, [Y, Z]]      window X is a row,
                 windows Y and Z are columns in the 2nd row
		   
		 +-------+
		 |   X   |
		 +---+---|
		 | Y | Z |
		 +---+---+

[[X, Y], [A, B]  windows X,Y are columns in the top row
                 windows A,B are columns in the bottom row

		 +-----+---+
		 |  X  | Y | Does not have to be a grid.
		 +---+-+---+ The columns in each row can be
		 | A |  B  | of arbitrary width
		 +---+-+---+

[[X, Y, Z], A]   +---+---+-----+  Z has diff width
                 | X | Y |  Z  |
		 +---+---+-----+
		 |      A      |
		 +-------------+

[[[X, Y], Z], A] +---+---+  Rows X,Z in colums XY,Z
                 | X |   |  in rows [XY,Z],A
                 +---+ Z |
                 | Y |   |  RowA
                 +---+---+    Cola
                 |   A   |      RowB - X
                 +-------+      RowC - Y
		              Colb   - Z
			    RowD     - A

┏━━━━━━━━━━━━━━━━┓
┃   2025-09-23   ┃
┗━━━━━━━━━━━━━━━━┛

Could we just do this with math?
- How do we know who gets our space when we close?
  - left/top sibling
  - everything collapse back to its parent
       OR
    parents reclaim their children's space when the last
    child dies, otherwise, siblings reclaim their siblings'
    space when they die.

Reclaiming children & collapsing unecessary rows/columns

  - 1st diagram row: tree diagram
  - 2nd diagram row: recursive alternating (row,col) list representation
  - 3rd diagram row: 2D window diagram

     Step 1                Step 2                 Step 3
==============================================================

  1. RowA                  RowA                   RowA - X
       Cola - X              Cola - X
       Colb                    RowC - Z
         RowB - Y          ----OR------
         RowC - Z          RowA
                             Cola - X
                             Colb - Z

  2. [[X, [Y,Z]]]           [[X,[Z]]              [X]
           		    OR
                            [[X, Z]]

  3. +--+---+              +---+---+              +---+---+
     |  | Y |              |   |   |              |       |
     |X +---+  --Y-dies--> | X | Z | --Z-dies-->  |   X   |
     |  | Z |              |   |   |              |       |
     +--+---+              +---+---+              +---+---+

                           Z reclaims             X reclaims
                           sibling Y's            child Z's
                           space                  space

                              AND (?)                OR

                           The rows for           Did Z become
                           Z and Y disappear      a _sibling_
                           and Y becomes a        of X when it
                           a column?              was the only
                                                  row left?

Use file-tree style diagrams to lay out rows and columns

*                 *                  *
| Row A           | Row A            | Row A
  | Col a           | Col a            | Col a
  | Col b           | Col b            | Col b
    | Row B           | Row B            | Row B
  | col c           | col c            | col c
    | Row C           | Row C x
       | col d (window)
       | col e (window)
    | Row D x
      | col f

    Window
---------------   [Window, [ Window , [ Window , Window] ]]
Window | Window

┏━━━━━━━━━━━━━━━━┓
┃   2025-09-22   ┃
┗━━━━━━━━━━━━━━━━┛

If we want to "shift move" a window to the extreme left or right, then we need
to wrap the current window tree in a row, and add a column.

  If we want to "shift move" a window to the extreme top or bottom, then we can
  simply add a new row at the beginning of the top list of rows, or at the end
  of the top list of rows.

  "shift move" is when you do C-w, [HJKL] e.g.

    X* |                  |   |
    ---| Z  + C-w,L =   Y | Z | X
     Y |                  |   |

    i.e. current window X has moved to the right of all other windows, leaving
    Y to take up the entire column.

  We can model this as

  one row: [[[X, Y], Z]] => [[Y, Z, X]]

   X
  ---  ->  Y | X       Two rows goes down to one row with two columns
   Y

  Move X from a top row to a right-hand column:

  two rows: [            [             -- all rows
             [ X ],   ->  [            -- row 1
             [ Y ]         [           -- col 1-1
            ]               [_, Y]     -- row 1-1-1, row 1-1-2
                           ],
                           [ X ]       -- col 1-2
                          ]
                         ]

    1. wrap the existing two rows in a new row (row 1) and column (col 1-1)
       Now we have Row 1, Column 1-1, Row 1-1-1 (X), Row 1-1-2 (Y)
    2. add a second column to the new top-level row 1
       Now we have Row 1, Columns 1-1 and 1-2, and col 1-1 has rows 1-1-1 and 1-1-2
    3. move X to the new column
       Now we have Row 1, Cols 1-1 (Y) 1-2 (X)

    I don't know of a non-confusing way to write this

    +---+       +-------+-----+   We wrap the existing two rows with a new top-level
    | X |       | +---+ |     |   row with two columns
    +---+  -->  | | X | |     |
    | Y |       | +---+ |     |
    +---+       | | Y | |     |
                | +---+ |     |
                +-------+-----+

   +-------+-----+
   | +---+ |     |  We move X over to the new top level right-hand column
   | | _ | |     |
   | +---+ |  X  |
   | | Y | |     |
   | +---+ |     |
   +-------+-----+

   +-------+-----+
   |       |     |  We simplify the two rows in column 1-1 down to just
   |       |     |  single window.
   |   Y   |  X  |
   |       |     |  (1-1 refers to row 1, column 1; it's not a cartesian
   |       |     |   coordinate, it's a tree index.)
   +-------+-----+

       Three rows would the same, except we wouldn't simplify 1-1-2 down to 1-1
       (i.e. row 1, col 1, row 1 down to row 1 col 1)

   "Shift" Moves:
   1. Move row window to right hand column
   2. Move row window to left hand column
   3. Move any window to top row
   4. Move any window to bottom row

   Other than shift moves, we only have window splits, rotates, and swaps.
   - rotate is switching two neighbour windows in the same column or same row
   - swap is swapping two arbitrary windows

[] -> [[[x]]]
   -> [[[x]]]

┏━━━━━━━━━━━━━━━━┓
┃   2025-09-21   ┃
┗━━━━━━━━━━━━━━━━┛

Window organization & borders:

  The screen has rows, rows can have columns, columns can have rows, ...

  X
  --     2 rows
  Y

  X | Z
  -----       2 rows, row 1 has two columns
    Y

    X
  -----
  Y | Z       3 rows, row 2 has 2 columns
  -----
    W

    X  |
  -----|
  Y | Z| A    1 row, column 1 has 3 rows, row {1,2} has 2 columns
  -----|
    W  |

If you go from   X   to   Y |    you've gone from 3 rows, to 1 row with 2 columns,
                ---      ---| X
                 Y        Z |
                ---
                 Z

and rows 2 and 3 now part of column 1 of row 1.

[Row(X), Row(Y), Row(Z)] -> [Row[Col[Row(Y),Row(Z)],Col(X)]]

                            [[[Y, [Z,A]],[X]]]

[[X], [Y], [Z]] -> [ [ [Y, Z],[X]]]
^                  ^ ^ ^      ^
|                  | | Col 1  Col 2
|                  | Row 1
|                  List of Rows, of which there is 1
List of rows, of which there are three

      *             *              *         *
    / | \           |            / | \       |
   R  R  R          R           R  R  R      R
   |  |  |        /   \         |  |  |     / \
   C  C  C       C     C        X  Y  Z    C   X
   |  |  |      / \     \                 / \
   X  Y  Z     R   R     X               Y   Z
               |   |
               Y   Z

┏━━━━━━━━━━━━━━━━┓
┃   2025-09-20   ┃
┗━━━━━━━━━━━━━━━━┛

A gen_server will manage the windows. It starts with one window. It doesn't draw
anything, it just knows where the windows are. I'm not sure if it will know
where the _first_ window is, and everything else is relative to that, of if it
will know where all the windows are. If you closed the first window, it would
have to decide what the next window was.

I'm going to play around with window arrangements with x's for windows

xx

x
x

x x
 x

I think in Vim every window can be split. One thing _I'd_ like to have, is
telling a window to move to split another window

go from  x x to   x   i.e. top-right becomes bottom right. You _might_ be
          x      x x
able to do that in vim with a rotate. I'm not sure.


┏━━━━━━━━━━━━━━━━┓
┃   2025-09-16   ┃
┗━━━━━━━━━━━━━━━━┛

I want to model windows (or panes) like tmux or vim.

I'll need a width and height. Maybe.

I could model them as splits: you start with the main window and then start
splitting it; or I could give them fixed sizes and positions.
