┏━━━━━━━━━━━━━━━━┓
┃   2025-10-17   ┃
┗━━━━━━━━━━━━━━━━┛

TODO:
x don't overwrite the status line of the window above
- implement enter key
- redraw screen on clear (F1)
- wrapping to next line
- saving to document
- listen for SIGWINCH for window size change
- insert mode / command mode
  - Add dispatch gen_server
    - dispatch either to screen or command

What element of the system would load a document from disk?
- cs_io? No, it deals with inputs and outputs ... screen and keyboard

  Oh, a buffer process, of course.

  cs_io sends data to the buffer, the buffer tells the window.

  How do we manage the spatial relationship of what the buffer contains and
  where it's written on screen?

  1) Have the buffer and window track line numbers: buffer tells the window that
  lines X:Y have been updated.

  2) Have the buffer and window track line numbers and columns.

  3) Have the buffer and window track blocks: x1,y1 to x2,y2

  4) 

                            Insert Mode          
                                 │               
                                 │               
┌─────────┐       ┌───────────┐  │    ┌─────────┐
│cs_io    ├──────►│cs_dispatch├──┴───►│cs_screen│
└─────────┘       └──────────┬┘       └─────────┘
                             │        ┌─────────┐
                             └───┬───►│cs_cmd   │
                                 │    └─────────┘
                                 │               
                                 │               
                            Normal Mode          


Using Ctrl+= and Ctrl+- to zoom in and out in asciiflow.com:

 ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 ┃ const canvas = document.getElementById('ascii-canvas');
 ┃ function dispatchZoom(delta) {
 ┃ 
 ┃   const rect = canvas.getBoundingClientRect();
 ┃   const event = new WheelEvent('wheel', {
 ┃     bubbles: true, cancelable: true, deltaY: delta * 10,  // Scale your preferred step (e.g., *5 for subtler)
 ┃     clientX: rect.left + rect.width / 2,
 ┃     clientY: rect.top + rect.height / 2
 ┃   });
 ┃   canvas.dispatchEvent(event);
 ┃ }
 ┃ document.addEventListener('keydown', (e) => {
 ┃   if (e.ctrlKey) {  // Ctrl key (Mac-safe, no page zoom conflict)
 ┃     if (e.key === '=') { dispatchZoom(-1); e.preventDefault(); }
 ┃     if (e.key === '-') { dispatchZoom(1); e.preventDefault(); }
 ┃   }
 ┃ });
 ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Entering Unicode (or other special chars) in Neovim with key codes:

:h i_CTRL-v & :h i_CTRL-v_digit

 ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 ┃ first     char mode    max   nr of chars   max value ~
 ┃ (none)    decimal      3     255
 ┃ o or O    octal        3     377           (255)
 ┃ x or X    hexadecimal  2     ff            (255)
 ┃ u         hexadecimal  4     ffff          (65535)
 ┃ U         hexadecimal  8     7fffffff      (2147483647)
 ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


┏━━━━━━━━━━━━━━━━┓
┃   2025-10-16   ┃
┗━━━━━━━━━━━━━━━━┛

TODO:
x don't overwrite the status line of the window above
- implement enter key
- redraw screen on clear (F1)
- wrapping to next line
- saving to document
- listen for SIGWINCH for window size change

┏━━━━━━━━━━━━━━━━┓
┃   2025-10-15   ┃
┗━━━━━━━━━━━━━━━━┛

Focus is done.

TODO:
- don't overwrite the status line of the window above
- implement enter key
- redraw screen on clear (F1)
- wrapping to next line
- saving to document
- listen for SIGWINCH for window size change

┏━━━━━━━━━━━━━━━━┓
┃   2025-10-08   ┃
┗━━━━━━━━━━━━━━━━┛

Move focus up

┌───┐ ┌───────────────┐  A -> A
│   │ │       B       │  B -> B
│   │ └───────────────┘  C -> B
│   │ ┌───┐ ┌─────────┐  D -> B
│ A │ │   │ │    D    │  E -> D
│   │ │   │ └─────────┘  F -> D
│   │ │ C │ ┌───┐ ┌───┐  X -> F
│   │ │   │ │   │ │ F │
│   │ │   │ │ E │ ├───┤  [[A, [[B], [[c],[[D],[[E],[[F],[X]]]]]]]]  
│   │ │   │ │   │ │ X │
└───┘ └───┘ └───┘ └───┘  
                         
A: parent row is undefined
B: parent row is undefined                                                  
C: parent row is B                                                          
   
   How do we store parent row?                                              
                                                     
   [[ ... first row ... ]]                                                  
                                                     
   Previous row == undefined.                                               
                                                                             
   Enter 2nd column, first row, i.e. [B]
   Set window = head of row                                                 
                                                                             
   How do we know if we're in a row?                                        
   I think we have to flip back and forth from 'row'
   to 'column'.

   When we enter a row we set {row, undefined}.
   When we hit our first window, we set {row, FirstWindow}

   We can't set our first window until we leave that window, ...
   except that if the window was focused it doesn't matter.


┏━━━━━━━━━━━━━━━━┓
┃   2025-10-07   ┃
┗━━━━━━━━━━━━━━━━┛

┌───┐ ┌───────────────┐  A -> B
│   │ │       B       │  B -> B
│   │ └───────────────┘  C -> D
│   │ ┌───┐ ┌─────────┐  D -> D
│ A │ │   │ │    D    │  E -> F
│   │ │   │ └─────────┘  F -> F
│   │ │ C │ ┌───┐ ┌───┐  X -> X
│   │ │   │ │   │ │ F │
│   │ │   │ │ E │ ├───┤
│   │ │   │ │   │ │ X │
└───┘ └───┘ └───┘ └───┘

┌───────────────┐ ┌───┐  B -> A
│       B       │ │   │  D -> C
└───────────────┘ │   │  F -> E
┌─────────┐ ┌───┐ │   │  X -> E
│    D    │ │   │ │ A │  C -> A
└─────────┘ │   │ │   │  A -> A
┌───┐ ┌───┐ │ C │ │   │
│ F │ │   │ │   │ │   │  [[[[B], [[[D], [[[F],[X]], E]], C]], A]]
├───┤ │ E │ │   │ │   │
│ X │ │   │ │   │ │   │  After we've found the focused window then next
└───┘ └───┘ └───┘ └───┘  window we find that hasn't been visited yet is
                         the new focused window.

                         e.g. check B, check D, check F, check X, X has focus!
                              D visits the next sibling, E. E hasn't been visited
                              yet and we've found the current focus, so E becomes
                              focused.
┌───┐┌───┐
│   ││ X │  We can't go down a row, but how do we tell that the next sibling is
└───┘└───┘  a row?
┌────────┐
│    Z   │
└────────┘

Okay, I ran into this:
┌───┬───┐
│ X │   │ How do we skip Y and go to Z?
├───┤ Z │ I chose to mark that we found X in a colum, and as soon as that list of columns
│ Y │   │ is done, we flip to say we're on rows. We skip any rows until we find another
└───┴───┘ column: the only way we can find another column is if there's windows to the right
          of us, i.e. Z.

          If we had found this: ┌───┬───┬───┐ then we won't flip {found, column} to {found, row}
                                │ X │ Y │   │ until we've dealt with Y, at which point we've found
                                ├───┴───┤ A │ a window to the right.
                                │   Z   │   │ It's only when X is the last column in a row that we
                                └───────┴───┘ have to skip all the sibling rows.


┏━━━━━━━━━━━━━━━━┓
┃   2025-10-04   ┃
┗━━━━━━━━━━━━━━━━┛

A window should have a buffer process that stores all the text.
For example, if the buffer has a line that's 1000 characters long, the window shouldn't care, it
should just display what it can, based on the line-wrapping setting.

I don't like the name "buffer". A buffer seems like something that temporarily holds something, or
adds a layer of overflow between to things.

"File" could be confused with something stored on disk. "Temp file" seems like what I need: you need
to make your temp file permanent if you want to keep it. Granted, I plan to save the temp file in
case the user *doesn't* save it. The user's file is what we use when they decide they want to
overwrite their data with the data that's in the temp file.
"backup file"?
"safety file"?
"working file"?
"scratch"? it's not meant to be thrown away
"hidden file"
"save" / "save file" confused with actually writing the file to disk

I mean, I guess if you were using the buffer to store data while it was being written, that would
make sense, although we might call that a cache.

Someone has probably written an IEEE standard on this and spent hours debating it. That's okay, it's
my project and I get to explore the consequences of my decisions.

memory file?
memory chunk?
memory copy? "mem_copy" would sound like a C or assembly instruction.
memory backup?
memory storage?
memory document mem_doc
RAM copy
running copy
working copy
draft - I like it - it's version that's not done, not ready for publication, i.e. writing to disk.
document - doesn't mean file: "You have unsaved documents"
page - implies something phsyical, some kind of partial segment of something
scroll
parchment
book
treatise
snippet
chunk
text - confusing: portion of text is also text

A note on Function keys and modifiers:

Using F12 as an example because F1-F4 are a litle goofy.

The plain F12 key has a Flag of 1, which is not shown

Plain   =  1
Shift   = +1
Option  = +2
Control = +4

ESC[24~    F12   Plain (1)
ESC[24;2~  F12 + Plain (1) + Shift (1) = 2
ESC[24;3~  F12 + Plain (1) + Option (2) = 3
ESC[22;4~  F12 + Plain (1) + Shift (1) + Option (2) = 4
ESC[24;6~  F12 + Plain (1) + Shift (1) + Control (4) = 6
ESC[24;7~  F12 + Plain (1) + Option (2) + Control (4) = 7
ESC[24;8~  F12 + Plain (1) + Shift (1) + Option (2) + Control (4) = 7

So you add up the modifier flags and then add that to 1.

Everything past F4 uses ~ as the terminator, but:
F1 - P -> 1;2P -> 1;3P -> 1;4P -> 1;6P -> 1;7P -> 1;8P  (Ctrl+F1, `1;5P` doesn't work)
F2 - Q
F3 - R
F4 - S

Also, Shift+Option+F6 to Shift+Option+F10 are wrong in iTerm2

  I used Claude to find out where the key outputs were:

  See iTerm2/sources/VT100Output.m:565

  Line 563 (case 65): @"\e[15;10~" or @"\e[15;4~"
  Line 565 (case 66): @"\e[15;10~" or @"\e[15;4~" -- should be 17;4

Which window has focus ... No, which window is to the LEFT of the window that has focus?

 ┌─┐
 │X│ No window to the left
 └─┘
 ┌─┐
 │X│ No window to the left
 ├─┤
 │Y│
 └─┘
 ┌───┬───┐
 │ Z │   │ Move focus from X to Z.
 ├───┤ X │ Previous column, first row.
 │ Y │   │ [[[[Z],[Y]][X]]]
 └───┴───┘ Store [[Z],[Y]] as previous column,
           then when we hit X, we can go into
           the previous column and get the ...
           rightmost column of the top row?

 ┌───┬───┬───┐
 │ A │ B │   │ X should go to B: rightmost column
 ├───┴───┤ X │ of top row of previous entity.
 │   C   │   │
 └───────┴───┘

Save the entity before X, then if X is the focused window, we can go back and find the top right
window in the previous entity.

  - keep [[[A,B],[C]]] as the previous entity
  - find focused window
  - find top right entity in [[[A,B],[C]]]
    - row has 1 column [[A,B],[C]]
    - column has 2 rows, take the first [A,B]
    - take the last column in the row B

  "top" means the first row
  "bottom" means the last row
  "left" measn the first column
  "right" means the last column

  Store the current entity (row or column)
  Track whether it's a row or column for up/down vs. left/right
  Check the next entity ... how do I know what the next entity is?

 ┌───┬───┬───┐ 1) start in top column [[[[X,B],[C]],A]] as there's only ever one
 │ X │ B │   │ 2) check first row [[X,B],[C]], A
 ├───┴───┤ A │ 3) check the first column [[X,B],[C]]
 │   C   │   │ 4) check first row [X,B]
 └───────┴───┘ 5) check first column X - match

               What was the previous entity at:
               1? none
               2? none
               3? none
               4? none
               5? none - you can't move left

 ┌───┬───┬───┐ 1) start in top column [[[[A,X],[C]],B]] as there's only ever one
 │ A │ X │   │ 2) check first row [[A,X],[C]], B
 ├───┴───┤ B │ 3) check the first column [[A,X],[C]]
 │   C   │   │ 4) check first row [A,X]
 └───────┴───┘ 5) check first column A
               6) check the second column

               What was the previous entity at:
               1? none
               2? none
               3? none
               4? none
               5? none
               6? A - focus can move to A

 ┌───┬───┬───┐ 1) start in top column [[[[A,B],[X]],C]] as there's only ever one
 │ A │ B │   │ 2) check first row [[A,B],[X]],C
 ├───┴───┤ C │ 3) check the first column [[A,B],[X]]
 │   X   │   │ 4) check first row [A,B]
 └───────┴───┘ 5) check first column A
               6) check the second column B
               7) check the second row [X]
               8) check the first column X

               What was the previous entity at:
               1? none
               2? none
               3? none
               4? none
               5? none
               6? A
               7? [A,B]
               8? [A,B]

               I'm missing something here, I think

               What if I wanted to go up? I go up & left by default

 ┌───┬───┬───┐  1) start in top column [[[[A,B],[X,D]],C]] as there's only ever one
 │ A │ B │   │  2) check first row [[A,B],[X,D]],C
 ├───┼───┤ C │  3) check the first column [[A,B],[X,D]]
 │ X │ D │   │  4) check first row [A,B]
 └───┴───┴───┘  5) check first column A
                6) check the second column B
                7) check the second row [X,D]
                8) check the first column X

                What was the previous entity at:
                1? none
                2? none
                3? none
                4? none
                5? none
                6? A
                7? [A,B]
                8? [A,B]

                You set the last element whenever you leave something.
                At step 6 we left column A for column B.
                At step 7 we left row [A,B] for row [X,D]

                Should we go left to [A,B]? It's a above us.

                If we're going left we should only track columns.
                We might have to track multiple columns in a stack.

┌───┬───┬───┐   1) start in top column [[[[A,B],[D,X]],C]] as there's only ever one
│ A │ B │   │   2) check first row [[A,B],[D,X]],C
├───┼───┤ C │   3) check the first column [[A,B],[D,X]]
│ D │ X │   │   4) check first row [A,B]
└───┴───┴───┘   5) check first column A
                6) check the second column B
                7) check the second row [D,X]
                8) check the first column D
                9) check the second column X

                What was the previous entity at:
                1? none
                2? none
                3? none
                4? none
                5? none
                6? A
                7? [A,B]
                8? D

                We go left to D.
                Can we go

 ┌───┬───┬───┐  1) start in top column [[C, [[A,B],[D,X]]]] as there's only ever one
 │   │ A │ B │  2) check first row C, [[A,B],[D,X]]
 │ C ├───┼───┤  3) check the first column C
 │   │ D │ X │  4) check the second column [[A,B],[D,X]]
 └───┴───┴───┘  5) check the first row [A,B]
                6) check the first column A
                7) check the second column B
                8) check the second row [D,X]
                9) check the first column D
               10) check the second column X

                What was the previous entity at:
                1? none
                2? none
                3? none
                4? C
                5? C
                6? C
                7? A
                8? B
                9? B
               10? D (works)

 ┌───┬───┬───┐  1) start in top column [[C, [[A,B],[X,D]]]] as there's only ever one
 │   │ A │ B │  2) check first row C, [[A,B],[X,D]]
 │ C ├───┼───┤  3) check the first column C
 │   │ X │ D │  4) check the second column [[A,B],[X,D]]
 └───┴───┴───┘  5) check the first row [A,B]
                6) check the first column A
                7) check the second column B
                8) check the second row [X,D]
                9) check the first column X

                What was the previous entity at:
                1? none
                2? none
                3? none
                4? C
                5? C
                6? C
                7? A
                8? B  - should revert to C because we've exited a row
                9? B  (doesn't work, should be C)

If we're going left, we track a list of the most recent columns. We track previous columns in this
rows, and previous columns in parent rows.

 ┌───┬───────────┐ [[A, [[B],[C,[[D,E],[X,F]]]]]]
 │   │     B     │
 │   ├───┬───┬───┤ We should be tracking columns:
 │ A │   │ D │ E │ A
 │   │ C ├───┼───┤ A,B
 │   │   │ X │ F │ A,C   <- pop B off the stack, we've exited that row
 └───┴───┴───┴───┘ A,C,D
                   A,C   <- pop D off the stack, we've exited that row

 ┌───────────┐ [[[[A],[B]],[[C],[X]]]]
 │┌───┐ ┌───┐│
 ││ A │ │ C ││ B and X look like sibling columns, but they aren't.
 │├───┤ ├───┤│ Can we go from X left to B?
 ││ B │ │ X ││
 │└───┘ └───┘│
 └───────────┘
   ┌───┬───┐
   │ A │ C │ This is what the above could look like.
   ├───┤   │
   │ B ├───┤
   │   │ X │
   └───┴───┘

   ┌───┬───┐
   │ A │ E │ Should X go to B, or C, or A, or none?
   ├───┤   │
   │ B ├───┤ [[[[A],[B],[C],[D]],[[E],[X],[F]]]]
   ├───┤ X │
   │ C ├───┤ 1) Check first column (there's always the top level column), 1 row: [[[A],[B],[C],[D]],[[E],[X],[F]]]
   ├───┤ F │ 2) Check first row, 2 columns: [[A],[B],[C],[D]], [[E],[X],[F]]
   │ D │   │ 3) Check first column, 4 rows: [A],[B],[C],[D]
   └───┴───┘ 4) Check first row, 1 column: [A]
             5) Check first column: A
                Don't push A onto stack because there's no more columns
             6) Check second row, 1 column: [B]
             7) Check first column: B
                Don't push B onto stack because there's no more columns
             8) Check third row, 1 column: [C]
             9) Check first column: C
                Don't push C onto stack because there's no more columns
            10) Check fourth row, 1 column: [D]
            11) Check first column: D
                Don't push D onto stack because there's no more columns
            12) Check second column, 3 rows: [E], [X], [F]
            13) Check first row, 1 column: [E]
            14) Check first column: E
                Don't push E onto stack because there's no more columns
            13) Check second row, 1 column: [X]
            14) Check first column: X
                Stack is empty, there is no previous column

            How do we save A as the "top of previous column"?

   ┌───┬───┬───┐ Should X go to A or B? B, closest column in top of previous column
   │ A │ B │ F │
   ├───┴───┤   │ If I had two stacks:
   │   C   ├───┤ - top of previous column
   ├───────┤ X │   - used when X is in the left-most column of it's row
   │   D   ├───┤ - previous column
   ├───────┤ G │
   │   E   │   │
   └───────┴───┘

   ┌───┬───┬───┬───┐  So we'd push A onto the "top of column" stack: [A]
   │   │ B │ C │ G │  Oh, when we go to the BCDEF column we can push B
   │   ├───┴───┤   │  onto the stack, then C ... but then ... oh, we don't
   │   │   D   ├───┤  need to pop them off until we exit the row.
   │ A ├───────┤ X │  X will see [A, B, C] and pop off C
   │   │   E   ├───┤
   │   ├───────┤ H │  [[A, [[B, C],[D],[E],[F]],[[G],[X],[H]]]]
   │   │   F   │   │
   └───┴───────┴───┘ 
   1) Top column, 1 row: [A, [[B, C],[D],[E],[F]],[[G],[X],[H]]]
   2)   1st row, 3 columns: A, [[B, C],[D],[E],[F]], [[G],[X],[H]]
   3)     1st column, A
   4)     push A onto top_column_stack: [A]
   5)   2nd column, 4 rows: [B, C], [D], [E], [F]
   6)     1st row: [B, C]
   7)       1st column: B   ... how do I know I'm in the first row of a column? flag?
   8)       push B onto top_column_stack: [B, A]
   9)       2nd column: C
  10)       push C onto top_column_stack: [C, B, A]
  11)     2nd row, 1 column
  12)       1st column: D
  13)     3rd row, 1 column
  14)       1st column: E
  15)     4th row, 1 column
  16)       1st column: F
  17)  3rd column, 3 rows: [G], [X], [H]
  18)    1st row, 1 column
  19)      1st column G
  20)    2nd row, 1 column
  21)      1st column X       No sibling column stack, go to top_column_stack

So, we have two stacks, the "top of previous parent columns" stack, and the sibling columns stack.

┌───┐ ┌───────────────┐   [[A, [[B], [C,[[D], [E,[[F],[X]]]]]]]]
│ A │ │       B       │
│   │ └───────────────┘   Push A, Push B, Push C, Push D, Push E, push F
│   │ ┌───┐ ┌─────────┐
│   │ │   │ │    D    │   Huh, that's not going to work, because then X would
│   │ │   │ └─────────┘   switch focus to F, not E.
│   │ │ C │ ┌───┐ ┌───┐
│   │ │   │ │   │ │ F │   Unless the row added the top-right column upon leaving the row.
│   │ │   │ │ E │ ├───┤   That wouldn't help it E has focus.
│   │ │   │ │   │ │ X │
└───┘ └───┘ └───┘ └───┘   Maybe upon leaving the column? That wouldn't help either, because
                          'D' is a column inside a row. (Rows *must* be lists.)

                          If you go down a row you don't pass yourself down, you only pass
                          the current top_column_stack.

                          e.g.
                          Push A
                          B doesn't push
                          Push C
                          D doesn't push
                          Push E
                          F doesn't Push
                          X pops E

                          If X wasn't there then F would push itself, actually it wouldn't because
                          ... why? Because B is the top-right of the 2nd column.

                          We're leaving the F ... but if this was E ... well it wouldn't matter
                          because D and then B are going to push themselves, burying F.

                          If you aren't above the focused window, your parent row-columns will bury
                          you on the stack.

                          Rules:
                          1) If you're leaving a column, push onto the stack before descending
                          2) If you're leaving a row, push onto the stack after descending.

┏━━━━━━━━━━━━━━━━┓
┃   2025-10-02   ┃
┗━━━━━━━━━━━━━━━━┛

Need a state machine to read in escape codes we only read in one character at a time now.

As soon as we get an ESC we set a timer and start checking to see if we're getting an escape code.
Escape codes should come in thick and fast since they're from the terminal. Once the timer goes off,
if we haven't found a valid escape code, then we just parse all the characters as regular
characters. For example, in Vim the ESC key is just "exit normal mode".

┏━━━━━━━━━━━━━━━━┓
┃   2025-09-29   ┃
┗━━━━━━━━━━━━━━━━┛

The `t` modifier in the io:fwrite ... thingies causes unicode.
Works with ~c, ~s, and ... a few others.

U+2588 ... the 2588 is in base 16 (hex).

 [begin [io:format("~tc ~p  ", [X, X]) || X <- lists:seq(N, N+8)], io:format("~n") end || N <- lists:seq(9472, 9641, 8)].
─ 9472  ━ 9473  │ 9474  ┃ 9475  ┄ 9476  ┅ 9477  ┆ 9478  ┇ 9479  ┈ 9480
┈ 9480  ┉ 9481  ┊ 9482  ┋ 9483  ┌ 9484  ┍ 9485  ┎ 9486  ┏ 9487  ┐ 9488
┐ 9488  ┑ 9489  ┒ 9490  ┓ 9491  └ 9492  ┕ 9493  ┖ 9494  ┗ 9495  ┘ 9496
┘ 9496  ┙ 9497  ┚ 9498  ┛ 9499  ├ 9500  ┝ 9501  ┞ 9502  ┟ 9503  ┠ 9504
┠ 9504  ┡ 9505  ┢ 9506  ┣ 9507  ┤ 9508  ┥ 9509  ┦ 9510  ┧ 9511  ┨ 9512
┨ 9512  ┩ 9513  ┪ 9514  ┫ 9515  ┬ 9516  ┭ 9517  ┮ 9518  ┯ 9519  ┰ 9520
┰ 9520  ┱ 9521  ┲ 9522  ┳ 9523  ┴ 9524  ┵ 9525  ┶ 9526  ┷ 9527  ┸ 9528
┸ 9528  ┹ 9529  ┺ 9530  ┻ 9531  ┼ 9532  ┽ 9533  ┾ 9534  ┿ 9535  ╀ 9536
╀ 9536  ╁ 9537  ╂ 9538  ╃ 9539  ╄ 9540  ╅ 9541  ╆ 9542  ╇ 9543  ╈ 9544
╈ 9544  ╉ 9545  ╊ 9546  ╋ 9547  ╌ 9548  ╍ 9549  ╎ 9550  ╏ 9551  ═ 9552
═ 9552  ║ 9553  ╒ 9554  ╓ 9555  ╔ 9556  ╕ 9557  ╖ 9558  ╗ 9559  ╘ 9560
╘ 9560  ╙ 9561  ╚ 9562  ╛ 9563  ╜ 9564  ╝ 9565  ╞ 9566  ╟ 9567  ╠ 9568
╠ 9568  ╡ 9569  ╢ 9570  ╣ 9571  ╤ 9572  ╥ 9573  ╦ 9574  ╧ 9575  ╨ 9576
╨ 9576  ╩ 9577  ╪ 9578  ╫ 9579  ╬ 9580  ╭ 9581  ╮ 9582  ╯ 9583  ╰ 9584
╰ 9584  ╱ 9585  ╲ 9586  ╳ 9587  ╴ 9588  ╵ 9589  ╶ 9590  ╷ 9591  ╸ 9592
╸ 9592  ╹ 9593  ╺ 9594  ╻ 9595  ╼ 9596  ╽ 9597  ╾ 9598  ╿ 9599  ▀ 9600
▀ 9600  ▁ 9601  ▂ 9602  ▃ 9603  ▄ 9604  ▅ 9605  ▆ 9606  ▇ 9607  █ 9608
█ 9608  ▉ 9609  ▊ 9610  ▋ 9611  ▌ 9612  ▍ 9613  ▎ 9614  ▏ 9615  ▐ 9616
▐ 9616  ░ 9617  ▒ 9618  ▓ 9619  ▔ 9620  ▕ 9621  ▖ 9622  ▗ 9623  ▘ 9624
▘ 9624  ▙ 9625  ▚ 9626  ▛ 9627  ▜ 9628  ▝ 9629  ▞ 9630  ▟ 9631  ■ 9632
■ 9632  □ 9633  ▢ 9634  ▣ 9635  ▤ 9636  ▥ 9637  ▦ 9638  ▧ 9639  ▨ 9640
▨ 9640  ▩ 9641  ▪ 9642  ▫ 9643  ▬ 9644  ▭ 9645  ▮ 9646  ▯ 9647  ▰ 9648

Sounds like I'm going to need a NIF to turn off Ctrl-l (L) causing a screen clear.

See [tcsetattr]

┏━━━━━━━━━━━━━━━━┓
┃   2025-09-28   ┃
┗━━━━━━━━━━━━━━━━┛

Been working on split window tree.

I'm working on drawing borders. I left cs_screen.erl in a broken state.

  - What window am I "in"
  - maybe make the cursor visible so we can see focus
    - Change border color for focused window
  - need to switch to the new split_window function
  - need to call layout
  - need to tell each window to draw itself
    - could maybe happen while drawing: all windows are dependent
      on windows drawn before.
      - until someone resizes the bottom-right window, and now
        other windows have been adjusted to fit the remaining space.
  - each window needs its translate function

Further on I'll need a dedicated, configurable parser.
But let's just draw some windows first.

I still need to add the SIGWINCH signal handler for window resizes.

┏━━━━━━━━━━━━━━━━┓
┃   2025-09-17   ┃
┗━━━━━━━━━━━━━━━━┛

figured out how to start Erlang and shut it down without an Escript:

  % rebar3 compile && erl -noshell -pa _build/default/lib/cm_shell/ebin -s cm_shell_app start
  ===> Verifying dependencies...
  ===> Analyzing applications...
  ===> Compiling cm_shell
  call cm_shell_sup:start_link()
  super init
  cm_shell_io:start_link()
  cm_shell_io:init([])
  cm_shell_io:handle_cast(start, _State)
  Hello world 0
  Hello world
  ok
    after io:formatcm_shell_io terminated
                                         Application cm_shell stopping

  I was able to get the checkerboard (xo table) to print. Yay!

  A couple key things to note:
  - The `-s Mod Fun Arg` argument to `erl` passes [Arg] as the arguments,
    unless you provide zero arguments. So we do `-s Mod Fun` and call
    cm_shell_app start with no args, and then have *that* call
    application:start(cm_shell). If we just try and do `-s application start
    cm_shell` then it will try and call `application:start([cm_shell])`, which
    doesn't work.
  - In order to get the supervisor to shut down we mark our one gen_server child
    as "significant" and "transient": transient means it doesn't need to be
    restarted, significant means if it stops, the supervisor might stop.
  - To stop the gen_server with no errors we have to set the reason to `normal`
    ... I think.
  - In order to get the supervisor to shut down we set `auto_shutdown` to
    `any_significat`: if any "significant" child shuts down, the supervisor
    stops. The child can't be `permanent`, otherwise the supervisor has to keep
    trying to restart it until it blows it's restart breaker.
  - In order to get Erlang to stop we use the Application `stop/1` call back and
    call halt(). Apparently, once the supervisor stops, the application stops.
  - `-s` and `-S` have slightly different argument handling.

┏━━━━━━━━━━━━━━━━┓
┃   2025-09-16   ┃
┗━━━━━━━━━━━━━━━━┛

To Do:
- Draw a vertical split between windows; I'll probably need to model windows and maintain a list of them
  See [windows]
