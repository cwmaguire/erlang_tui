┏━━━━━━━━━━━━━━━━┓
┃   2025-10-02   ┃
┗━━━━━━━━━━━━━━━━┛

Need a state machine to read in escape codes we only read in one character at a time now.

As soon as we get an ESC we set a timer and start checking to see if we're getting an escape code.
Escape codes should come in thick and fast since they're from the terminal. Once the timer goes off,
if we haven't found a valid escape code, then we just parse all the characters as regular
characters. For example, in Vim the ESC key is just "exit normal mode".

┏━━━━━━━━━━━━━━━━┓
┃   2025-09-29   ┃
┗━━━━━━━━━━━━━━━━┛

The `t` modifier in the io:fwrite ... thingies causes unicode.
Works with ~c, ~s, and ... a few others.

U+2588 ... the 2588 is in base 16 (hex).

 [begin [io:format("~tc ~p  ", [X, X]) || X <- lists:seq(N, N+8)], io:format("~n") end || N <- lists:seq(9472, 9641, 8)].
─ 9472  ━ 9473  │ 9474  ┃ 9475  ┄ 9476  ┅ 9477  ┆ 9478  ┇ 9479  ┈ 9480
┈ 9480  ┉ 9481  ┊ 9482  ┋ 9483  ┌ 9484  ┍ 9485  ┎ 9486  ┏ 9487  ┐ 9488
┐ 9488  ┑ 9489  ┒ 9490  ┓ 9491  └ 9492  ┕ 9493  ┖ 9494  ┗ 9495  ┘ 9496
┘ 9496  ┙ 9497  ┚ 9498  ┛ 9499  ├ 9500  ┝ 9501  ┞ 9502  ┟ 9503  ┠ 9504
┠ 9504  ┡ 9505  ┢ 9506  ┣ 9507  ┤ 9508  ┥ 9509  ┦ 9510  ┧ 9511  ┨ 9512
┨ 9512  ┩ 9513  ┪ 9514  ┫ 9515  ┬ 9516  ┭ 9517  ┮ 9518  ┯ 9519  ┰ 9520
┰ 9520  ┱ 9521  ┲ 9522  ┳ 9523  ┴ 9524  ┵ 9525  ┶ 9526  ┷ 9527  ┸ 9528
┸ 9528  ┹ 9529  ┺ 9530  ┻ 9531  ┼ 9532  ┽ 9533  ┾ 9534  ┿ 9535  ╀ 9536
╀ 9536  ╁ 9537  ╂ 9538  ╃ 9539  ╄ 9540  ╅ 9541  ╆ 9542  ╇ 9543  ╈ 9544
╈ 9544  ╉ 9545  ╊ 9546  ╋ 9547  ╌ 9548  ╍ 9549  ╎ 9550  ╏ 9551  ═ 9552
═ 9552  ║ 9553  ╒ 9554  ╓ 9555  ╔ 9556  ╕ 9557  ╖ 9558  ╗ 9559  ╘ 9560
╘ 9560  ╙ 9561  ╚ 9562  ╛ 9563  ╜ 9564  ╝ 9565  ╞ 9566  ╟ 9567  ╠ 9568
╠ 9568  ╡ 9569  ╢ 9570  ╣ 9571  ╤ 9572  ╥ 9573  ╦ 9574  ╧ 9575  ╨ 9576
╨ 9576  ╩ 9577  ╪ 9578  ╫ 9579  ╬ 9580  ╭ 9581  ╮ 9582  ╯ 9583  ╰ 9584
╰ 9584  ╱ 9585  ╲ 9586  ╳ 9587  ╴ 9588  ╵ 9589  ╶ 9590  ╷ 9591  ╸ 9592
╸ 9592  ╹ 9593  ╺ 9594  ╻ 9595  ╼ 9596  ╽ 9597  ╾ 9598  ╿ 9599  ▀ 9600
▀ 9600  ▁ 9601  ▂ 9602  ▃ 9603  ▄ 9604  ▅ 9605  ▆ 9606  ▇ 9607  █ 9608
█ 9608  ▉ 9609  ▊ 9610  ▋ 9611  ▌ 9612  ▍ 9613  ▎ 9614  ▏ 9615  ▐ 9616
▐ 9616  ░ 9617  ▒ 9618  ▓ 9619  ▔ 9620  ▕ 9621  ▖ 9622  ▗ 9623  ▘ 9624
▘ 9624  ▙ 9625  ▚ 9626  ▛ 9627  ▜ 9628  ▝ 9629  ▞ 9630  ▟ 9631  ■ 9632
■ 9632  □ 9633  ▢ 9634  ▣ 9635  ▤ 9636  ▥ 9637  ▦ 9638  ▧ 9639  ▨ 9640
▨ 9640  ▩ 9641  ▪ 9642  ▫ 9643  ▬ 9644  ▭ 9645  ▮ 9646  ▯ 9647  ▰ 9648

Sounds like I'm going to need a NIF to turn off Ctrl-l (L) causing a screen clear.

See [tcsetattr]

┏━━━━━━━━━━━━━━━━┓
┃   2025-09-28   ┃
┗━━━━━━━━━━━━━━━━┛

Been working on split window tree.

I'm working on drawing borders. I left cs_screen.erl in a broken state.

  - What window am I "in"
  - maybe make the cursor visible so we can see focus
    - Change border color for focused window
  - need to switch to the new split_window function
  - need to call layout
  - need to tell each window to draw itself
    - could maybe happen while drawing: all windows are dependent
      on windows drawn before.
      - until someone resizes the bottom-right window, and now
        other windows have been adjusted to fit the remaining space.
  - each window needs its translate function

Further on I'll need a dedicated, configurable parser.
But let's just draw some windows first.

I still need to add the SIGWINCH signal handler for window resizes.

┏━━━━━━━━━━━━━━━━┓
┃   2025-09-17   ┃
┗━━━━━━━━━━━━━━━━┛

figured out how to start Erlang and shut it down without an Escript:

  % rebar3 compile && erl -noshell -pa _build/default/lib/cm_shell/ebin -s cm_shell_app start
  ===> Verifying dependencies...
  ===> Analyzing applications...
  ===> Compiling cm_shell
  call cm_shell_sup:start_link()
  super init
  cm_shell_io:start_link()
  cm_shell_io:init([])
  cm_shell_io:handle_cast(start, _State)
  Hello world 0
  Hello world
  ok
    after io:formatcm_shell_io terminated
                                         Application cm_shell stopping

  I was able to get the checkerboard (xo table) to print. Yay!

  A couple key things to note:
  - The `-s Mod Fun Arg` argument to `erl` passes [Arg] as the arguments,
    unless you provide zero arguments. So we do `-s Mod Fun` and call
    cm_shell_app start with no args, and then have *that* call
    application:start(cm_shell). If we just try and do `-s application start
    cm_shell` then it will try and call `application:start([cm_shell])`, which
    doesn't work.
  - In order to get the supervisor to shut down we mark our one gen_server child
    as "significant" and "transient": transient means it doesn't need to be
    restarted, significant means if it stops, the supervisor might stop.
  - To stop the gen_server with no errors we have to set the reason to `normal`
    ... I think.
  - In order to get the supervisor to shut down we set `auto_shutdown` to
    `any_significat`: if any "significant" child shuts down, the supervisor
    stops. The child can't be `permanent`, otherwise the supervisor has to keep
    trying to restart it until it blows it's restart breaker.
  - In order to get Erlang to stop we use the Application `stop/1` call back and
    call halt(). Apparently, once the supervisor stops, the application stops.
  - `-s` and `-S` have slightly different argument handling.

┏━━━━━━━━━━━━━━━━┓
┃   2025-09-16   ┃
┗━━━━━━━━━━━━━━━━┛

To Do:
- Draw a vertical split between windows; I'll probably need to model windows and maintain a list of them
  See [windows]
