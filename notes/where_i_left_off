┏━━━━━━━━━━━━━━━━┓
┃   2025-10-04   ┃
┗━━━━━━━━━━━━━━━━┛

A window should have a buffer process that stores all the text.
For example, if the buffer has a line that's 1000 characters long, the window shouldn't care, it
should just display what it can, based on the line-wrapping setting.

I don't like the name "buffer". A buffer seems like something that temporarily holds something, or
adds a layer of overflow between to things.

"File" could be confused with something stored on disk. "Temp file" seems like what I need: you need
to make your temp file permanent if you want to keep it. Granted, I plan to save the temp file in
case the user *doesn't* save it. The user's file is what we use when they decide they want to
overwrite their data with the data that's in the temp file.
"backup file"?
"safety file"?
"working file"?
"scratch"? it's not meant to be thrown away
"hidden file"
"save" / "save file" confused with actually writing the file to disk

I mean, I guess if you were using the buffer to store data while it was being written, that would
make sense, although we might call that a cache.

Someone has probably written an IEEE standard on this and spent hours debating it. That's okay, it's
my project and I get to explore the consequences of my decisions.

memory file?
memory chunk?
memory copy? "mem_copy" would sound like a C or assembly instruction.
memory backup?
memory storage?
memory document mem_doc
RAM copy
running copy
working copy
draft - I like it - it's version that's not done, not ready for publication, i.e. writing to disk.
document - doesn't mean file: "You have unsaved documents"
page - implies something phsyical, some kind of partial segment of something
scroll
parchment
book
treatise
snippet
chunk
text - confusing: portion of text is also text

A note on Function keys and modifiers:

Using F12 as an example because F1-F4 are a litle goofy.

The plain F12 key has a Flag of 1, which is not shown

Plain   =  1
Shift   = +1
Option  = +2
Control = +4

ESC[24~    F12   Plain (1)
ESC[24;2~  F12 + Plain (1) + Shift (1) = 2
ESC[24;3~  F12 + Plain (1) + Option (2) = 3
ESC[22;4~  F12 + Plain (1) + Shift (1) + Option (2) = 4
ESC[24;6~  F12 + Plain (1) + Shift (1) + Control (4) = 6
ESC[24;7~  F12 + Plain (1) + Option (2) + Control (4) = 7
ESC[24;8~  F12 + Plain (1) + Shift (1) + Option (2) + Control (4) = 7

So you add up the modifier flags and then add that to 1.

Everything past F4 uses ~ as the terminator, but:
F1 - P -> 1;2P -> 1;3P -> 1;4P -> 1;6P -> 1;7P -> 1;8P  (Ctrl+F1, `1;5P` doesn't work)
F2 - Q
F3 - R 
F4 - S 

Also, Shift+Option+F6 to Shift+Option+F10 are wrong in iTerm2
 
  I used Claude to find out where the key outputs were:

  See iTerm2/sources/VT100Output.m:565

  Line 563 (case 65): @"\e[15;10~" or @"\e[15;4~"
  Line 565 (case 66): @"\e[15;10~" or @"\e[15;4~" -- should be 17;4


┏━━━━━━━━━━━━━━━━┓
┃   2025-10-02   ┃
┗━━━━━━━━━━━━━━━━┛

Need a state machine to read in escape codes we only read in one character at a time now.

As soon as we get an ESC we set a timer and start checking to see if we're getting an escape code.
Escape codes should come in thick and fast since they're from the terminal. Once the timer goes off,
if we haven't found a valid escape code, then we just parse all the characters as regular
characters. For example, in Vim the ESC key is just "exit normal mode".

┏━━━━━━━━━━━━━━━━┓
┃   2025-09-29   ┃
┗━━━━━━━━━━━━━━━━┛

The `t` modifier in the io:fwrite ... thingies causes unicode.
Works with ~c, ~s, and ... a few others.

U+2588 ... the 2588 is in base 16 (hex).

 [begin [io:format("~tc ~p  ", [X, X]) || X <- lists:seq(N, N+8)], io:format("~n") end || N <- lists:seq(9472, 9641, 8)].
─ 9472  ━ 9473  │ 9474  ┃ 9475  ┄ 9476  ┅ 9477  ┆ 9478  ┇ 9479  ┈ 9480
┈ 9480  ┉ 9481  ┊ 9482  ┋ 9483  ┌ 9484  ┍ 9485  ┎ 9486  ┏ 9487  ┐ 9488
┐ 9488  ┑ 9489  ┒ 9490  ┓ 9491  └ 9492  ┕ 9493  ┖ 9494  ┗ 9495  ┘ 9496
┘ 9496  ┙ 9497  ┚ 9498  ┛ 9499  ├ 9500  ┝ 9501  ┞ 9502  ┟ 9503  ┠ 9504
┠ 9504  ┡ 9505  ┢ 9506  ┣ 9507  ┤ 9508  ┥ 9509  ┦ 9510  ┧ 9511  ┨ 9512
┨ 9512  ┩ 9513  ┪ 9514  ┫ 9515  ┬ 9516  ┭ 9517  ┮ 9518  ┯ 9519  ┰ 9520
┰ 9520  ┱ 9521  ┲ 9522  ┳ 9523  ┴ 9524  ┵ 9525  ┶ 9526  ┷ 9527  ┸ 9528
┸ 9528  ┹ 9529  ┺ 9530  ┻ 9531  ┼ 9532  ┽ 9533  ┾ 9534  ┿ 9535  ╀ 9536
╀ 9536  ╁ 9537  ╂ 9538  ╃ 9539  ╄ 9540  ╅ 9541  ╆ 9542  ╇ 9543  ╈ 9544
╈ 9544  ╉ 9545  ╊ 9546  ╋ 9547  ╌ 9548  ╍ 9549  ╎ 9550  ╏ 9551  ═ 9552
═ 9552  ║ 9553  ╒ 9554  ╓ 9555  ╔ 9556  ╕ 9557  ╖ 9558  ╗ 9559  ╘ 9560
╘ 9560  ╙ 9561  ╚ 9562  ╛ 9563  ╜ 9564  ╝ 9565  ╞ 9566  ╟ 9567  ╠ 9568
╠ 9568  ╡ 9569  ╢ 9570  ╣ 9571  ╤ 9572  ╥ 9573  ╦ 9574  ╧ 9575  ╨ 9576
╨ 9576  ╩ 9577  ╪ 9578  ╫ 9579  ╬ 9580  ╭ 9581  ╮ 9582  ╯ 9583  ╰ 9584
╰ 9584  ╱ 9585  ╲ 9586  ╳ 9587  ╴ 9588  ╵ 9589  ╶ 9590  ╷ 9591  ╸ 9592
╸ 9592  ╹ 9593  ╺ 9594  ╻ 9595  ╼ 9596  ╽ 9597  ╾ 9598  ╿ 9599  ▀ 9600
▀ 9600  ▁ 9601  ▂ 9602  ▃ 9603  ▄ 9604  ▅ 9605  ▆ 9606  ▇ 9607  █ 9608
█ 9608  ▉ 9609  ▊ 9610  ▋ 9611  ▌ 9612  ▍ 9613  ▎ 9614  ▏ 9615  ▐ 9616
▐ 9616  ░ 9617  ▒ 9618  ▓ 9619  ▔ 9620  ▕ 9621  ▖ 9622  ▗ 9623  ▘ 9624
▘ 9624  ▙ 9625  ▚ 9626  ▛ 9627  ▜ 9628  ▝ 9629  ▞ 9630  ▟ 9631  ■ 9632
■ 9632  □ 9633  ▢ 9634  ▣ 9635  ▤ 9636  ▥ 9637  ▦ 9638  ▧ 9639  ▨ 9640
▨ 9640  ▩ 9641  ▪ 9642  ▫ 9643  ▬ 9644  ▭ 9645  ▮ 9646  ▯ 9647  ▰ 9648

Sounds like I'm going to need a NIF to turn off Ctrl-l (L) causing a screen clear.

See [tcsetattr]

┏━━━━━━━━━━━━━━━━┓
┃   2025-09-28   ┃
┗━━━━━━━━━━━━━━━━┛

Been working on split window tree.

I'm working on drawing borders. I left cs_screen.erl in a broken state.

  - What window am I "in"
  - maybe make the cursor visible so we can see focus
    - Change border color for focused window
  - need to switch to the new split_window function
  - need to call layout
  - need to tell each window to draw itself
    - could maybe happen while drawing: all windows are dependent
      on windows drawn before.
      - until someone resizes the bottom-right window, and now
        other windows have been adjusted to fit the remaining space.
  - each window needs its translate function

Further on I'll need a dedicated, configurable parser.
But let's just draw some windows first.

I still need to add the SIGWINCH signal handler for window resizes.

┏━━━━━━━━━━━━━━━━┓
┃   2025-09-17   ┃
┗━━━━━━━━━━━━━━━━┛

figured out how to start Erlang and shut it down without an Escript:

  % rebar3 compile && erl -noshell -pa _build/default/lib/cm_shell/ebin -s cm_shell_app start
  ===> Verifying dependencies...
  ===> Analyzing applications...
  ===> Compiling cm_shell
  call cm_shell_sup:start_link()
  super init
  cm_shell_io:start_link()
  cm_shell_io:init([])
  cm_shell_io:handle_cast(start, _State)
  Hello world 0
  Hello world
  ok
    after io:formatcm_shell_io terminated
                                         Application cm_shell stopping

  I was able to get the checkerboard (xo table) to print. Yay!

  A couple key things to note:
  - The `-s Mod Fun Arg` argument to `erl` passes [Arg] as the arguments,
    unless you provide zero arguments. So we do `-s Mod Fun` and call
    cm_shell_app start with no args, and then have *that* call
    application:start(cm_shell). If we just try and do `-s application start
    cm_shell` then it will try and call `application:start([cm_shell])`, which
    doesn't work.
  - In order to get the supervisor to shut down we mark our one gen_server child
    as "significant" and "transient": transient means it doesn't need to be
    restarted, significant means if it stops, the supervisor might stop.
  - To stop the gen_server with no errors we have to set the reason to `normal`
    ... I think.
  - In order to get the supervisor to shut down we set `auto_shutdown` to
    `any_significat`: if any "significant" child shuts down, the supervisor
    stops. The child can't be `permanent`, otherwise the supervisor has to keep
    trying to restart it until it blows it's restart breaker.
  - In order to get Erlang to stop we use the Application `stop/1` call back and
    call halt(). Apparently, once the supervisor stops, the application stops.
  - `-s` and `-S` have slightly different argument handling.

┏━━━━━━━━━━━━━━━━┓
┃   2025-09-16   ┃
┗━━━━━━━━━━━━━━━━┛

To Do:
- Draw a vertical split between windows; I'll probably need to model windows and maintain a list of them
  See [windows]
